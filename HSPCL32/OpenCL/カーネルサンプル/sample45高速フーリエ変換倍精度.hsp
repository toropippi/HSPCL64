/////////////////////////////////////////////////////////////////////////////////////////////////
//倍精度コーソクフーリエ変換
//このサンプルはhsptv掲示板のために作ったものであったが流用
/////////////////////////////////////////////////////////////////////////////////////////////////

#include "hspcl32.as"
	HCLini 1
	if HCLDevCount=0:dialog "対応ビデオカードがありません。終了します",1:end

	HCLSetDev 0;0番目のデバイスを使って計算する
	
	HCLBuildProgram "fftdp.cl",prgid;
	HCLCreateKernel prgid,"fft",krnfft;
	HCLCreateKernel prgid,"kbitReverse",krnrev;

	冪指数=10
	n=1<<冪指数

	HCLCreateBuffer fftarray,n*2*8;1要素当たり実数と虚数があり、1つの数字は8byte
	HCLCreateBuffer fftarrayd,n*2*8;ダミー

	gosub*fftの初期値設定

	HCLSetKernel krnfft,0,fftarrayd;
	HCLSetKernel krnfft,1,n;
	HCLSetKernel krnfft,2,冪指数
	HCLSetKernel krnrev,0,fftarray
	HCLSetKernel krnrev,1,fftarrayd
	HCLSetKernel krnrev,2,冪指数


	//GPUでFFTの部分/////////////////////////////////////////////////////////
	HCLDoKrn1 krnrev,n,0;ビット逆順。これで結果がfftarraydに入る。
	repeat 冪指数//冪指数回ループ。cntもカーネルで使用する
		HCLSetKernel krnfft,3,cnt
		HCLDoKrn1 krnfft,n/2,0;fftの1段階実行
	loop
	HCLWaitTask
	//GPUでFFTの部分/////////////////////////////////////////////////////////


	HCLReadBuffer fftarrayd,reim,n*2*8//結果取得






///////////;√(実数部^2+虚数部^2) が特定周波数の振幅を表す。画面右側は反転部
	screen 0,n,256:title "fft解析後"
	color 128,128,128:boxf n/2,0,n,128
	color 0,0,0
	pos 0,128
	repeat n
		re=reim(cnt*2)
		im=reim(cnt*2+1)
		line cnt,128+int(-sqrt(re*re+im*im)/8.0)//実数部と虚数部の絶対値をとっているが、これは厳密にはリアルではない。実数部と虚数部は位相のズレがあるため、同じ要素数で足すのはあまりよくない
	loop
///////////////

	HCLbye
	stop






*fftの初期値設定
	ddim reim,n*2;実数部→虚数部→実数部→実数部→虚数部→実数部→虚数部→実数部→虚数部→実数部→虚数部→実数部→虚数部→実数部→虚数部→の順に並んでいる
	周波数その1=50.0;Hz
	周波数その2=100.0;Hz
	周波数その3=120.0;Hz
	周波数その4=198.0;Hz
	周波数その5=245.0;Hz
	周波数その6=311.0;Hz
	周波数その7=351.0;Hz

//////////////;実数部にwaveデータ
	repeat n
		reim(cnt*2)=1.1*sin(周波数その1*6.283185307179586*cnt/n)+1.7*sin(周波数その2*6.283185307179586*cnt/n)
		reim(cnt*2)+=1.2*sin(周波数その3*6.283185307179586*cnt/n)+1.9*sin(周波数その4*6.283185307179586*cnt/n)
		reim(cnt*2)+=1.3*sin(周波数その5*6.283185307179586*cnt/n)+1.8*sin(周波数その6*6.283185307179586*cnt/n)
		reim(cnt*2)+=1.4*sin(周波数その7*6.283185307179586*cnt/n)
	loop
//////////////


////////////wave波形表示
	screen 1,n,256
	pos 0,128
	title "wave波形"
	repeat n
		line cnt,128+int(reim(cnt*2)*16.0)
	loop
////////////
	HCLWriteBuffer fftarray,reim,n*2*8
	return





*検算
	beki=冪指数
	LIST_SIZE=1<<beki
	LIST_SIZE2=LIST_SIZE>>1
	LIST_SIZE8=LIST_SIZE<<3
	ddim hsp_data_i,n//実数
	ddim hsp_data_r,n//虚数
	repeat n
		hsp_data_i(cnt)=1.0*(cnt)//とりあえず実数部だけ代入
	loop
	fft hsp_data_i,hsp_data_r,1

	pos 0,200
	mes "cpuで計算、実数部"
	repeat n
		mes hsp_data_i(cnt)
	loop

	pos 320,200
	mes "cpuで計算、虚数部"
	repeat n
		mes hsp_data_r(cnt)
	loop
	return

























////検算用。HSPソース側のfft
#deffunc fft array A,array B,int inv
	ddim c,LIST_SIZE
	ddim d,LIST_SIZE

	repeat beki;fft
	bekii=LIST_SIZE>>(cnt+1)
		repeat LIST_SIZE2
		t2 = cnt\bekii;
		t0 = (cnt/bekii)*bekii*2 + t2;
		t1 = t0+bekii;
		r4=A(t1)
		i4=B(t1);
		rm0=A(t0)-r4
		im0=B(t0)-i4;
		pii=-3.14159265358979323846264338328*t2/bekii*inv;
		dsin=sin(pii)
		dcos=cos(pii);
		A(t0) += r4;
		B(t0) += i4;
		A(t1) = rm0*dcos-im0*dsin;
		B(t1) = rm0*dsin+im0*dcos;
		loop
	loop


	repeat LIST_SIZE;ビット逆順
	ic=cnt/65536
	ic = (ic&0x00005555)<<1 | (ic&0x0000AAAA)>>1;
	ic = (ic&0x00003333)<<2 | (ic&0x0000CCCC)>>2;
	ic = (ic&0x00000F0F)<<4 | (ic&0x0000F0F0)>>4;
	ic = (ic&0x000000FF)<<8 | (ic&0x0000FF00)>>8;
	iic=cnt\65536
	iic = (iic&0x00005555)<<1 | (iic&0x0000AAAA)>>1;
	iic = (iic&0x00003333)<<2 | (iic&0x0000CCCC)>>2;
	iic = (iic&0x00000F0F)<<4 | (iic&0x0000F0F0)>>4;
	iic = (iic&0x000000FF)<<8 | (iic&0x0000FF00)>>8;
	ic=(iic*32768+ic/2)>>(31-beki);
	C(cnt)=A(ic)
	D(cnt)=B(ic)
	loop

	if inv=-1{
			repeat LIST_SIZE
			a.cnt=c.cnt/LIST_SIZE
			b.cnt=d.cnt/LIST_SIZE
			loop
		}else{
			memcpy a,c,LIST_SIZE8
			memcpy b,d,LIST_SIZE8
		}
	return