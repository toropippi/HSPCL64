#include "hspcl32.as"
	HCLini 0
	HCLSetDev 0;計算に使うデバイス
	if HCLDevCount=0:dialog "対応ビデオカードがありません。終了します",1:end;openCL対応デバイス数


#define WX 128//変えるときはカーネルソースもかえること
#define WY 128//変えるときはカーネルソースもかえること
#define IM WX-1
#define JM WY-1
#define ijm WX*WY
#define ijm2 int(0.5*ijm)
#define ipn 4//変えるときはカーネルソースもかえること
#define konagire 4
#define taba 4
#define DT float(0.5)
#define DX float(1.0)
#define DY float(1.0)
#define にゅ〜 float(0.00001)//粘性項
#define speeed float(0.45)

	rDT=float(1.0/DT)
	arufa=にゅ〜*DT
	ar1fa=float(1.0/(1.0+4.0*arufa))



	screen 0,WX*ipn,WY*ipn
	mref iiii,66


	dim local_item_size,2
	local_item_size=128,1;１つのワークユニットに与える処理数、そのワークユニット内で共有メモリが使える
	global_item_size=WX,WY;１つのワークユニットに与える処理数、そのワークユニット内で共有メモリが使える
	lis1=local_item_size.0*local_item_size.1

	HCLBuildProgram "nabie.cl"	 	,prg;
	HCLCreateKernel prg,"newgrad"	,krn00;
	HCLCreateKernel prg,"newgrad"	,krn01;
	HCLCreateKernel prg,"newgrad"	,krn02;
	HCLCreateKernel prg,"dcip0"	 	,krn10;
	HCLCreateKernel prg,"dcip0"	 	,krn11;
	HCLCreateKernel prg,"dcip0"	 	,krn12;
	HCLCreateKernel prg,"nensei0" 	,krn50;
	HCLCreateKernel prg,"nensei1" 	,krn51;
	HCLCreateKernel prg,"pressure0"	,krn20;
	HCLCreateKernel prg,"pressure1"	,krn21;
	HCLCreateKernel prg,"div"	 	,krn22;
	HCLCreateKernel prg,"narasi"	 	,krn23;
	HCLCreateKernel prg,"rhs"	 	,krn3;
	HCLCreateKernel prg,"veloc"	 	,krn4;
	HCLCreateKernel prg,"copyy"	 	,copy;
	HCLCreateKernel prg,"out"	 	,kout;
	HCLCreateKernel prg,"out0"	 	,kout0;
	HCLCreateKernel prg,"syokise"	,syokise;
	HCLCreateKernel prg,"ryuusi"		,ryuusi;


	fdim kkx,WX*WY

	HCLCreateBuffer YU,4*WX*WY	:HCLWriteBuffer YU,kkx,4*WX*WY
	HCLCreateBuffer YUN,4*WX*WY	:HCLWriteBuffer YUN,kkx,4*WX*WY
	HCLCreateBuffer GXU,4*WX*WY	:HCLWriteBuffer GXU,kkx,4*WX*WY
	HCLCreateBuffer GYU,4*WX*WY	:HCLWriteBuffer GYU,kkx,4*WX*WY

	HCLCreateBuffer YV,4*WX*WY	:HCLWriteBuffer YV,kkx,4*WX*WY
	HCLCreateBuffer YVN,4*WX*WY	:HCLWriteBuffer YVN,kkx,4*WX*WY
	HCLCreateBuffer GXV,4*WX*WY	:HCLWriteBuffer GXV,kkx,4*WX*WY
	HCLCreateBuffer GYV,4*WX*WY	:HCLWriteBuffer GYV,kkx,4*WX*WY

	HCLCreateBuffer GXd0,4*WX*WY	:HCLWriteBuffer GXd0,kkx,4*WX*WY
	HCLCreateBuffer GYd0,4*WX*WY	:HCLWriteBuffer GYd0,kkx,4*WX*WY
	HCLCreateBuffer Yd0,4*WX*WY	:HCLWriteBuffer Yd0,kkx,4*WX*WY
	HCLCreateBuffer GXd1,4*WX*WY	:HCLWriteBuffer GXd1,kkx,4*WX*WY
	HCLCreateBuffer GYd1,4*WX*WY	:HCLWriteBuffer GYd1,kkx,4*WX*WY
	HCLCreateBuffer Yd1,4*WX*WY	:HCLWriteBuffer Yd1,kkx,4*WX*WY
	HCLCreateBuffer GXd2,4*WX*WY	:HCLWriteBuffer GXd2,kkx,4*WX*WY
	HCLCreateBuffer GYd2,4*WX*WY	:HCLWriteBuffer GYd2,kkx,4*WX*WY
	HCLCreateBuffer Yd2,4*WX*WY	:HCLWriteBuffer Yd2,kkx,4*WX*WY

	HCLCreateBuffer YP,4*WX*WY	:HCLWriteBuffer YP,kkx,4*WX*WY
	HCLCreateBuffer YPN,4*WX*WY	:HCLWriteBuffer YPN,kkx,4*WX*WY
	HCLCreateBuffer GXP,4*WX*WY	:HCLWriteBuffer GXP,kkx,4*WX*WY
	HCLCreateBuffer GYP,4*WX*WY	:HCLWriteBuffer GYP,kkx,4*WX*WY

	HCLCreateBuffer YUT,4*WX*WY	:HCLWriteBuffer YUT,kkx,4*WX*WY
	HCLCreateBuffer YVT,4*WX*WY	:HCLWriteBuffer YVT,kkx,4*WX*WY
	HCLCreateBuffer YUV,4*WX*WY	:HCLWriteBuffer YUV,kkx,4*WX*WY
	HCLCreateBuffer YVU,4*WX*WY	:HCLWriteBuffer YVU,kkx,4*WX*WY
	HCLCreateBuffer DIV,4*WX*WY	:HCLWriteBuffer DIV,kkx,4*WX*WY

	HCLCreateBuffer kabeP,WX*WY	:HCLWriteBuffer kabeP,kkx,WX*WY
	HCLCreateBuffer kabeX,WX*WY	:HCLWriteBuffer kabeX,kkx,WX*WY
	HCLCreateBuffer kabeY,WX*WY	:HCLWriteBuffer kabeY,kkx,WX*WY

	HCLCreateBuffer out,3*WX*WY*ipn*ipn;画面
	HCLCreateBuffer RYS,4*2*WX*WY*ipn*ipn:HCLSetKernel syokise,0,RYS:HCLDoKrn1 syokise,WX*ipn*WY*ipn,local_item_size.0*local_item_size.1;

	fdim kky,WX*WY

		repeat WY-1
		kkx(1+cnt*WX)=speeed
		loop
		repeat WY-1
		kkx(cnt*WX)=speeed
		loop

	HCLWriteBuffer YUN,kkx,4*WX*WY
	HCLWriteBuffer YVN,kky,4*WX*WY

	sdim kbp,WX*WY
	sdim kbx,WX*WY
	sdim kby,WX*WY

	buffer 1:picload "kabep.png"
		repeat WX:a3=cnt:repeat WY
			pget a3,cnt:poke kbp,a3+cnt*WX,ginfo_r
		loop:loop

	buffer 1:picload "kabex.png"
		repeat WX:a3=cnt:repeat WY
			pget a3,cnt:poke kbx,a3+cnt*WX,ginfo_r
		loop:loop

	buffer 1:picload "kabey.png"
		repeat WX:a3=cnt:repeat WY
			pget a3,cnt:poke kby,a3+cnt*WX,ginfo_r
		loop:loop

	buffer 1:picload "kabew.png"
		repeat WX:a3=cnt:repeat WY
			pget a3,cnt
			if ginfo_r=0{
			poke kbp,a3+cnt*WX,0
			poke kbx,a3+cnt*WX,0
			poke kbx,(a3+1)\WX+cnt*WX,0
			poke kby,a3+cnt*WX,0
			poke kby,a3+((cnt+1)\WY)*WX,0
		}
		loop:loop

	HCLWriteBuffer kabeP,kbp,WX*WY
	HCLWriteBuffer kabeX,kbx,WX*WY
	HCLWriteBuffer kabeY,kby,WX*WY

	gsel 0


	fdim kky,WX*WY
	fdim kkx,WX*WY
	fdim ryuusihspgawa,konagire*WY*ipn*2
		repeat konagire*WY*ipn
		w=cnt*2
		ryuusihspgawa.w=float((1.940389/taba)*(cnt/(WY*ipn/taba)))
		w+
		ryuusihspgawa.w=float((1.0*taba*cnt+0.5*taba+0.005)\(WY*ipn))
		loop
	yp00=float(0.0)
	gosub*syokisetei
	kirikaein=int(float(2.5)/speeed)


////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;cip移流(壁のところでは参照はするが書き込みはしない)、	 f値とg(微分)値が同時に更新される
;本コピが完璧にあっている
;3次関数の部分では第4/5引数の速度はf3を参照、1から3引数はf3、g1を入力、係数もf3とg1から決定、f4、g2を出力
;差分式では、f3とg2を参照
;f4とg3を出力
;ここで一段落


;→外力	 f値のみ更新f0→f1
;→発散f1参照
;→圧力sor(壁のところでは参照はするが書き込みはしない)
;→圧力射影	 f値のみ更新f1→f2
;→cip微分値反映(ニューグレード、ソースでは圧力の更新しか反映されてないが、外力も含めないとダメ、さっきg値が更新された時のf値から今のf値までどのくらいずれたか)g0→g1、f0とf2参照
;→拡散、これはf値のみの更新でいい。f2→f3、f2参照
;→　　→　はじめへ
*keisan
	copyy YU,YUN
	copyy YV,YVN
	copyy YP,YPN
	gosub*粘性
	if flm\8=0:gosub*外力
	gosub*pressure
	gosub*rhs
	gosub*newgrad
	gosub*veloc
	gosub*粒子
	if flm\kirikaein=(kirikaein-1):gosub*粒子復活
	if flm\8=0:gosub*表示
	gosub*dcip0
	if flm\8=0{
		getkey key,27:if key:goto*sthsr
		await 0
	}
	flm++
	flmps++
	goto*keisan

////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*粘性
	copyy GXd0,YUN
	copyy GYd0,YVN
		repeat limit(10000.0*にゅ〜,0,(WX+WY)/2)
		HCLDoKrn2 krn50,WX,WY,local_item_size.0,local_item_size.1;
		HCLDoKrn2 krn51,WX,WY,local_item_size.0,local_item_size.1;
		loop
	return

*外力
	mkey=key1
	stick key1,256
	if key1&256{
		imaxx=mousex
		imayy=mousey
		if mkey=0:omxx=imaxx:omyy=imayy
		xzzzsa=omxx-imaxx
		yzzzsa=omyy-imayy
		if (xzzzsa!0)|(yzzzsa!0)|(1){
			HCLReadBuffer YUN,kkx,4*WX*WY
			HCLReadBuffer YVN,kky,4*WX*WY
				repeat 16
				wwwx=(imaxx/ipn+cnt\4)\WX
				wwwy=(imayy/ipn+cnt/4)\WY
				if peek(kbx,wwwx+wwwy*WX):kkx(wwwx+wwwy*WX)-=float(0.013*xzzzsa)
				if peek(kby,wwwx+wwwy*WX):kky(wwwx+wwwy*WX)-=float(0.013*yzzzsa)
				loop
			HCLWriteBuffer YUN,kkx,4*WX*WY
			HCLWriteBuffer YVN,kky,4*WX*WY

		}
		omxx=imaxx
		omyy=imayy
	}
	return

*pressure
	HCLDoKrn2 krn22,WX,WY,local_item_size.0,local_item_size.1;div計算

/*ガス抜き
	if flm\128=7{
	HCLReadBuffer YPN,yp00,4,(WX*3+WX/2)*4
	dbgyp00=double(yp00)
	if (yp00<float(-99999999999.9))|(yp00>float(9999999999.9)):HCLbye:dialog "計算が発散しました。終了します":end
	HCLSetKernel krn23,1,yp00
	HCLDoKrn2 krn23,WX,WY,local_item_size.0,local_item_size.1;
}*/

	copyy YP,YPN
	//圧力計算はコストが高いのでとにかく最適化
		repeat WX
		HCLDoKrn1 krn20,ijm2,0
		HCLDoKrn1 krn21,ijm2,0//ローカルワークサイズはOpenCL実装に任せることに
		loop
	HCLwaittask//意外と安定性が増すみたい・・
	return

*rhs
	HCLDoKrn2 krn3,WX,WY,local_item_size.0,local_item_size.1;
	return

*newgrad
	HCLDoKrn2 krn00,WX,WY,local_item_size.0,local_item_size.1;
	HCLDoKrn2 krn01,WX,WY,local_item_size.0,local_item_size.1;
	HCLDoKrn2 krn02,WX,WY,local_item_size.0,local_item_size.1;
return

*veloc
	copyy YU,YUN
	copyy YV,YVN
	HCLDoKrn2 krn4,WX,WY,local_item_size.0,local_item_size.1;

	copyy GXd0,GXU
	copyy GYd0,GYU
	copyy Yd0,YUN

	copyy GXd1,GXV
	copyy GYd1,GYV
	copyy Yd1,YVN

	copyy GXd2,GXP
	copyy GYd2,GYP
	copyy Yd2,YPN
	return
*粒子
	HCLDoKrn1 ryuusi,WX*ipn*WY*ipn,local_item_size.0*local_item_size.1;
	return
*粒子復活
	HCLWriteBuffer RYS,ryuusihspgawa,konagire*WY*ipn*2*4,(konagire*WY*ipn*2*4*hktkais)\(WX*WY*ipn*ipn*4*2),0,1
	hktkais+
	return
*表示
	HCLDoKrn1 kout0,3*WX*WY*ipn*ipn/4,local_item_size.0*local_item_size.1;
	HCLDoKrn1 kout,WX*ipn*WY*ipn,local_item_size.0*local_item_size.1;
	HCLWaitTask
	HCLReadBuffer out,iiii,3*WX*WY*ipn*ipn
	pos 0,0:color 255,100,100
	redraw 1
	if mtim!gettime(6):mes "fps"+flmps:mflmps=flmps:flmps=0:else:mes "fps"+mflmps
	mtim=gettime(6)
	redraw 0
	return

*dcip0
	HCLDoKrn2 krn10,WX,WY,local_item_size.0,local_item_size.1;
	HCLDoKrn2 krn11,WX,WY,local_item_size.0,local_item_size.1;
	HCLDoKrn2 krn12,WX,WY,local_item_size.0,local_item_size.1;
	return

#deffunc copyy int a_1,int b_1
	HCLSetKernel copy,0,a_1
	HCLSetKernel copy,1,b_1
	HCLDoKrn2 copy,WX,WY,local_item_size.0,local_item_size.1;
	return



*sthsr
	HCLbye
	end





*syokisetei
	HCLSetKernel krn50,0,YU
	HCLSetKernel krn50,1,YUN
	HCLSetKernel krn50,2,YV
	HCLSetKernel krn50,3,YVN
	HCLSetKernel krn50,4,GXd0
	HCLSetKernel krn50,5,GYd0
	HCLSetKernel krn50,6,arufa
	HCLSetKernel krn50,7,ar1fa
	HCLSetKernel krn50,8,kabeX
	HCLSetKernel krn50,9,kabeY

	HCLSetKernel krn51,0,YU
	HCLSetKernel krn51,1,YUN
	HCLSetKernel krn51,2,YV
	HCLSetKernel krn51,3,YVN
	HCLSetKernel krn51,4,GXd0
	HCLSetKernel krn51,5,GYd0
	HCLSetKernel krn51,6,arufa
	HCLSetKernel krn51,7,ar1fa
	HCLSetKernel krn51,8,kabeX
	HCLSetKernel krn51,9,kabeY

	HCLSetKernel krn22,1,YUN
	HCLSetKernel krn22,2,YVN
	HCLSetKernel krn22,0,DIV

	HCLSetKernel krn20,0,DIV
	HCLSetKernel krn20,1,YPN
	HCLSetKernel krn20,2,kabeP
	HCLSetKernel krn21,0,DIV
	HCLSetKernel krn21,1,YPN
	HCLSetKernel krn21,2,kabeP

	HCLSetKernel krn23,0,YPN
	HCLSetKernel krn23,1,yp00

	HCLSetKernel krn3,0,YUN
	HCLSetKernel krn3,1,YVN
	HCLSetKernel krn3,2,YPN
	HCLSetKernel krn3,3,kabeX
	HCLSetKernel krn3,4,kabeY

	HCLSetKernel krn02,0,YUN
	HCLSetKernel krn02,1,YU
	HCLSetKernel krn02,2,GXU
	HCLSetKernel krn02,3,GYU
	HCLSetKernel krn02,4,kabeX

	HCLSetKernel krn00,0,YVN
	HCLSetKernel krn00,1,YV
	HCLSetKernel krn00,2,GXV
	HCLSetKernel krn00,3,GYV
	HCLSetKernel krn00,4,kabeY

	HCLSetKernel krn01,0,YPN
	HCLSetKernel krn01,1,YP
	HCLSetKernel krn01,2,GXP
	HCLSetKernel krn01,3,GYP
	HCLSetKernel krn01,4,kabeP

	HCLSetKernel krn4,0,YU
	HCLSetKernel krn4,1,YV
	HCLSetKernel krn4,2,YVU
	HCLSetKernel krn4,3,YUV
	HCLSetKernel krn4,4,YVT
	HCLSetKernel krn4,5,YUT

	HCLSetKernel krn10,0,YUN
	HCLSetKernel krn10,1,GXU
	HCLSetKernel krn10,2,GYU
	HCLSetKernel krn10,3,YU
	HCLSetKernel krn10,4,YVU
	HCLSetKernel krn10,5,GXd0
	HCLSetKernel krn10,6,GYd0
	HCLSetKernel krn10,7,Yd0
	HCLSetKernel krn10,8,DT
	HCLSetKernel krn10,9,kabeX

	HCLSetKernel krn11,0,YVN
	HCLSetKernel krn11,1,GXV
	HCLSetKernel krn11,2,GYV
	HCLSetKernel krn11,3,YUV
	HCLSetKernel krn11,4,YV
	HCLSetKernel krn11,5,GXd1
	HCLSetKernel krn11,6,GYd1
	HCLSetKernel krn11,7,Yd1
	HCLSetKernel krn11,8,DT
	HCLSetKernel krn11,9,kabeY

	HCLSetKernel krn12,0,YPN
	HCLSetKernel krn12,1,GXP
	HCLSetKernel krn12,2,GYP
	HCLSetKernel krn12,3,YUT
	HCLSetKernel krn12,4,YVT
	HCLSetKernel krn12,5,GXd2
	HCLSetKernel krn12,6,GYd2
	HCLSetKernel krn12,7,Yd2
	HCLSetKernel krn12,8,DT
	HCLSetKernel krn12,9,kabeP
	
	HCLSetKernel kout,0,out
	HCLSetKernel kout,1,RYS
	HCLSetKernel kout,2,YU
	HCLSetKernel kout,3,YV

	HCLSetKernel ryuusi,0,RYS
	HCLSetKernel ryuusi,1,YUN
	HCLSetKernel ryuusi,2,YVN
	HCLSetKernel ryuusi,3,DT
	HCLSetKernel ryuusi,4,GXU
	HCLSetKernel ryuusi,5,GYU
	HCLSetKernel ryuusi,6,GXV
	HCLSetKernel ryuusi,7,GYV

	HCLSetKernel kout0,0,out
	return
	