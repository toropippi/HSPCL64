/////////////////////////////////////////////////////////////////////////////////////////////////
;
;グラボ上でC=A+Bをやるプログラム。AとBとCはそれぞれ65536要素のint型配列変数

;流れとしては

;１グラボ上で動かすソースコード(カーネル)の文字列データを作成
;２ソースからプログラムid作成
;３プログラムidからカーネルid作成
;４HSP側でランダムな数をhsp_Aとhsp_B配列に代入
;５グラボ上にVRAM確保 (vram_A,vram_B,vram_C)
;６hsp_Aをvram_Aに、hsp_Bをvram_Bにコピー
;７カーネルの引数にvram_Aをセット
;８カーネルの引数にvram_Bをセット
;９カーネルの引数にvram_Cをセット
;１０カーネル実行(これでVRAMの中で加算が実行される、C=A+B)
;１１VRAMからvram_Cをhsp_Cへリード
;１２HSP画面に表示
;１３後片付け
/////////////////////////////////////////////////////////////////////////////////////////////////




#include "hspcl32.as"
	HCLini 1
	if HCLDevCount=0:dialog "対応ビデオカードがありません。終了します",1:end
	HCLSetDev 0;0番目のデバイスを使って計算する

	sdim progrms,2048;ソースコード
	progrms={"__kernel void addsamp(__global int *A, __global int *B, __global int *C) {
		int ic=get_global_id(0);
		C[ic]=A[ic]+B[ic];
	}
"}

	HCLCreateProgramWithSource progrms,strlen(progrms),prgid;ソースからプログラムid生成
	HCLCreateKernel prgid,"addsamp", krnid

	dim hsp_A,65536:repeat 65536:hsp_A.cnt=rnd(6000):loop
	dim hsp_B,65536:repeat 65536:hsp_B.cnt=rnd(6000):loop
	dim hsp_C,65536

	HCLCreateBuffer vram_A,65536*4;int型は4byteなのでサイズに4をかける
	HCLCreateBuffer vram_B,65536*4;
	HCLCreateBuffer vram_C,65536*4;

	HCLWriteBuffer vram_A,hsp_A,65536*4;hsp_A → vram_A  に全コピー
	HCLWriteBuffer vram_B,hsp_B,65536*4;hsp_B → vram_B  に全コピー

	HCLSetKernel krnid,0 ,vram_A;
	HCLSetKernel krnid,1 ,vram_B;ここに注目！HCLSetKernelの第二引数に1を指定している。これは__kernel void addint(__global int *A,__global int *B,__global int *C) の第ニ(第0から数えれば1番目の)引数「int *B」に「vram_B」をセットしますよということ。
	HCLSetKernel krnid,2 ,vram_C;ここは、カーネルのほうの第三引数にvram_Cを指定したいので、HCLSetKernelの第二引数に「2」を指定。
	//                ↑には、セットしたいカーネルの引数が第n番目だとしたらn-1を指定しなさい、ということ！このサンプルの一番言いたいところ

	HCLDoKernel krnid,1,65536,64;
	HCLWaitTask//機種によっては必要ないがこれやっぱ必要

	HCLReadBuffer vram_C,hsp_C,65536*4;vram_C → hsp_C  に65536配列コピー

	repeat 32//32こだけ表示
		mes ""+hsp_A.cnt+" + "+hsp_B.cnt+" = "+hsp_C.cnt;加算の計算はGPGPU
	loop
	HCLbye//後片付け
	dim hsp_A,1
	dim hsp_B,1
	dim hsp_C,1
	stop