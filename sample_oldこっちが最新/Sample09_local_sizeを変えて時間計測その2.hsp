//並列数が同じでも、local_sizeを変えると計算時間が変わってくることがわかりました。
//global_size(並列数)はlocal_sizeで割り切れないといけません。
//local_sizeで指定した数は1SM(1コア)内での並列数になるので、1SM=64 cuda coreだとすると、ここに奇数や素数など中途半端な値を指定すると
//待ちぼうけを食らうcuda coreが発生してしまいます。
#include "HSPCL64.as"
	HCLinit
	prg=HCLCreateProgram("VecAdd.cl")
	krn=HCLCreateKernel(prg,"vecAdd")
	
	n=1024*1024
	clmem_A=HCLCreateBuffer(n*4)
	clmem_B=HCLCreateBuffer(n*4)
	clmem_C=HCLCreateBuffer(n*4)
	
	dim host_A,n
	dim host_B,n
	dim host_C,n
		repeat n
		host_A.cnt=cnt
		host_B.cnt=cnt
		loop
	
	HCLWriteBuffer clmem_A,host_A,n*4,0,0//CPU→GPU
	HCLWriteBuffer clmem_B,host_B,n*4,0,0//CPU→GPU
	
	HCLSetKernel krn,0,clmem_A
	HCLSetKernel krn,1,clmem_B
	HCLSetKernel krn,2,clmem_C

	
		repeat 256
		local_size=cnt+1
		HCLDoKrn1 krn,n/local_size*local_size,local_size,cnt//同じ計算を、local_sizeだけ変えてなんどもやる
		HCLFinish
		loop
	HCLReadBuffer clmem_C,host_C,n*4,0,0//GPU→CPU

	//計算時間をグラフで表示
	
		repeat 256
		start_time=HCLGetEventLogs(cnt,6)
		end_time=HCLGetEventLogs(cnt,7)
		c_time=end_time-start_time
		if cnt==0{
			pos 0,460-c_time/196
		}else{
			line cnt*640/256,460-c_time/196
		}
		
		//mes "local_size = "+(cnt+1)+" のときの計算時間        "+c_time
		loop

	stop