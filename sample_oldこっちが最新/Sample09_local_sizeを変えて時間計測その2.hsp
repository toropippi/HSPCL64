//並列数が同じでも、local_sizeを変えると計算時間が変わってくることがわかりました。
//今度は1刻みで1〜128でやってみましょう。
//なおglobal_size(並列数)はlocal_sizeで割り切れないといけません。
#include "HSPCL64.as"
	HCLinit
	prg=HCLCreateProgram("VecAdd.cl")
	krn=HCLCreateKernel(prg,"vecAdd")
	
	n=1024*1024
	clmem_A=HCLCreateBuffer(n*4)
	clmem_B=HCLCreateBuffer(n*4)
	clmem_C=HCLCreateBuffer(n*4)
	
	dim host_A,n
	dim host_B,n
	dim host_C,n
		repeat n
		host_A.cnt=cnt
		host_B.cnt=cnt
		loop
	
	HCLWriteBuffer clmem_A,host_A,n*4,0,0//CPU→GPU
	HCLWriteBuffer clmem_B,host_B,n*4,0,0//CPU→GPU
	
	HCLSetKernel krn,0,clmem_A
	HCLSetKernel krn,1,clmem_B
	HCLSetKernel krn,2,clmem_C

	title "計算中..."
	wait 1
		repeat 128
		local_size=cnt+1
		HCLDoKrn1 krn,n/local_size*local_size,local_size,cnt//同じ計算を、local_sizeだけ変えてなんどもやる
		HCLFinish
		loop
	HCLReadBuffer clmem_C,host_C,n*4,0,0//GPU→CPU
	title "計算終了"


	dim c_time,128
		repeat 128
		start_time=HCLGetEventLogs(cnt,6)
		end_time=HCLGetEventLogs(cnt,7)
		c_time.cnt=end_time-start_time
		loop
	
	//計算時間をグラフで表示
	//まずは軸
	line 30,30,30,450
	line 30,30,27,35
	line 30,30,33,35
	pos 3,240
	font msgothic,12
	mes "時間"

	line 30,450,610,450
	line 610,450,605,447
	line 610,450,605,453
	pos 270,460
	mes "local_size"
		repeat 9
		pos 30+cnt*580/8,450
		mes 16*cnt
		loop


	t_scale=c_time.64//擬似的な中央値
	t_scale=t_scale/140+1
	pos 30,450-c_time/2096
		repeat 127,1
		line cnt*580/128+30,450-c_time.cnt/t_scale
		loop

	stop