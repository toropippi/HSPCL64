//「glVertex2dv」では座標値をCPU→GPUへ転送して描画している。このままではCPUとGPUの間のデータ転送のボトルネックがある。
//今回はCPUとGPUのデータ転送の無駄をなくしGPUに座標値を置いて、そのままGPUで表示するためにOpenGLのバッファオブジェクト(Buffer Object)を利用する
//特に頂点データのバッファオブジェクトである「VBO」を用いた図形描画のサンプルである

#include "hspcl32.as"
	HCLini
	HGLSetView

	ddim hsp_vertex,3*4//3情報(x,y,z)*4つの頂点
	hsp_vertex.0=-0.5,-0.5,0.0
	hsp_vertex.3=0.5,-0.5,0.0
	hsp_vertex.6=0.5,0.5,0.0
	hsp_vertex.9=-0.5,0.5,0.0

	size=3*4*8//8はsizeof(double)
	HGLCreateBuffer GLmemid,CLmemid,size;VRAMにデータバッファ作成(VBO)
	HGLWriteBuffer GLmemid,hsp_vertex,size;hsp_vertex→GLmemid(VRAM)にデータ転送


//////こっから描画
    glClearColor 1.0, 1.0, 0.0, 1.0//背景色指定、ｗ成分は1.0
    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);黒い背景初期化
	gluLookAt 0.0,0.0,1.0,0.0,0.0,0.0, 0.0,1.0,0.0//(x,y,z)=(0,0,1)から(0,0,0)を見つめたカメラ視点

    // 図形の描画
    glColor3d 0.0,0.0,1.0;
	glBindBuffer GL_ARRAY_BUFFER,GLmemid//VBOをバインド
	glEnableClientState GL_VERTEX_ARRAY//頂点データの配列を有効にする
	glVertexPointer 3,GL_DOUBLE,0,0//頂点データの場所を指定する、中身はdouble型です、頂点情報は3つ(x,y,z)で一セットです
	glDrawArrays GL_QUADS,0,4//頂点を4こ使います＝QUADSを1こ表示します
	glDisableClientState GL_VERTEX_ARRAY//後片付け。glEnableClientStateと対
	glBindBuffer GL_ARRAY_BUFFER,0//後片付け。バインド解除
//以下と同じことをしている
/*
	glBegin GL_QUADS;四角形一つ表示
	glVertex3d -0.5,-0.5,0.0//左下
	glVertex3d 0.5,-0.5,0.0//右下
	glVertex3d 0.5,0.5,0.0//右上
	glVertex3d -0.5,0.5,0.0//左上
	glEnd
*/
	glFinish//描画実行
	SwapBuffers wglGetCurrentDC()//前画面に出す
	HCLbye
	stop