//座標はddim v,3:v=1.0,2.0,3.0 のような配列の形で定義される事が多い。
//そのような場合にはglVertex3d関数の代わりにglVertex3dv関数を用いることができる。
//この関数の使用は以下のとおりになっており、引数として配列のポインタを与える。
#include "hspcl32.as"
	HCLini
	HGLSetView

	ang=0.0
	ddim vertex,3*4*2//(3つの頂点情報(x,y,z)がある 2つの 4角形ポリゴン)
	vertex.0 =-1.2, -1.2,0.3//頂点座標をメモリにセット
	vertex.3 =1.2, -1.2,0.3
	vertex.6 =1.2,  1.2,0.3
	vertex.9 =-1.2,  1.2,0.3
	vertex.12 =-2.2, -2.2,-0.3
	vertex.15 =2.2, -2.2,-0.3
	vertex.18 =2.2,  2.2,-0.3
	vertex.21 =-2.2,  2.2,-0.3

    repeat -1//無限ループ
	    glClearColor 0.0, 0.0, 0.0, 1.0
	    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);深度バッファとrgbピクセルカーラーバッファをクリア

		//視点の設定
		glPushMatrix//gluLookAtで行列が変えられちゃう前に登録
		gluLookAt 6.0*cos(ang),0.0,6.0*sin(ang),0.0,0.0,0.0, 0.0,1.0,0.0//視点は円状に回る。注視点は常に0,0,0

	    // 図形の描画
		glBegin GL_QUADS
		glcolor3d 0.5,0.5,0.5
		glVertex3dv varptr(vertex.0)//こうして頂点x,y,z3つまとめて指定できる
		glVertex3dv varptr(vertex.3)
		glVertex3dv varptr(vertex.6)
		glVertex3dv varptr(vertex.9)
	//	glEnd
	//	glBegin GL_QUADS//実はglBegin GL_QUADS〜glEndの中に2つのポリゴン情報を入れれば2つのポリゴンを表示してくれる。glBegin GL_QUADSを2回も3回も使わなくてもいい
		glcolor3d 1.0,1.0,1.0
		glVertex3dv varptr(vertex.12)
		glVertex3dv varptr(vertex.15)
		glVertex3dv varptr(vertex.18)
		glVertex3dv varptr(vertex.21)
		glEnd

		glFinish//描画実行
		glPopMatrix//glPushMatrixしたときの行列にもどす

		ang+=0.03
		await 16
		SwapBuffers wglGetCurrentDC()//前画面に出す
		getkey key,27:if key:HCLbye:end
	loop