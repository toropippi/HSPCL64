//「glDrawElements」応用編その２
//モデルの法線、ライト設定
//※OpenGLの仕様では法線やUVが頂点に割り当てられるため、フラットシェ−エディング(sample18ディフューズ)のように面に法線を割り当てることははできない。
#include "hspcl32.as"
	HCLini
	HGLSetView

	//立方体の頂点情報
	gosub*立方体頂点情報設定
	gosub*ライト設定
	gosub*アンビエント等設定

	gosub*VBO作成

//////こっから描画

    glClearColor 1.0, 1.0, 0.0, 1.0//背景色指定、ｗ成分は1.0


	repeat -1
		await 16
		glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
		glPushMatrix
		gluLookAt -4.0*sin(0.04*cnt),0.02*(mousex-320),0.02*(mousey-320),0.0,0.0,0.0,0.0,1.0,0.0
		glLightfv GL_LIGHT0,GL_POSITION,varptr(light_pos)
   		// 図形の描画

		/* 頂点データ，法線データ，テクスチャ座標の配列を有効にする */
		glEnableClientState GL_VERTEX_ARRAY
		glEnableClientState GL_NORMAL_ARRAY
//		glEnableClientState GL_TEXTURE_COORD_ARRAY

		/* 頂点データ，法線データ，テクスチャ座標の場所を指定する */
		glBindBuffer GL_ARRAY_BUFFER,GLmemid_v
		glVertexPointer 3,GL_DOUBLE,0,0//頂点データの場所を指定する。VBOを指定しててもp4はオフセットとして使える
		glNormalPointer GL_DOUBLE,0,varsize(hsp_vertex)//VBOを指定しててもp4はオフセットとして使える
//		glTexCoordPointer 2,GL_UNSIGNED_INT,0,varsize(hsp_vertex) + varsize(hsp_normal)//VBOを指定しててもp4はオフセットとして使える

		/* 頂点のインデックスの場所を指定して図形を描く */
		glBindBuffer GL_ELEMENT_ARRAY_BUFFER,GLmemid_f//エレメントをバインド
		glDrawElements GL_QUADS, 24, GL_UNSIGNED_INT, 0//エレメントどおりの順番で描画
		glBindBuffer GL_ELEMENT_ARRAY_BUFFER,0//後片付け。エレメントをアンバインド

		/* 頂点データ，法線データ，テクスチャ座標の配列を無効にする */
		glDisableClientState GL_VERTEX_ARRAY//後片付け
		glDisableClientState GL_NORMAL_ARRAY//後片付け
//		glDisableClientState GL_TEXTURE_COORD_ARRAY//後片付け
		glBindBuffer GL_ARRAY_BUFFER,0//後片付け。バインド解除

		glPopMatrix
		glFinish
		SwapBuffers wglGetCurrentDC()
		getkey key,27:if key:HCLbye:end
	loop




*立方体頂点情報設定
	ddim hsp_vertex,24
	hsp_vertex =-1.0, -1.0, 1.0 ,1.0, -1.0, 1.0 ,-1.0, 1.0, 1.0 ,1.0, 1.0, 1.0 ,-1.0, 1.0, -1.0 ,1.0, 1.0, -1.0 ,-1.0, -1.0, -1.0 ,1.0, -1.0, -1.0

	ddim hsp_normal,24//頂点1つにつき法線ベクトル1つ
	hsp_normal =-1.0, -1.0, 1.0 ,1.0, -1.0, 1.0 ,-1.0, 1.0, 1.0 ,1.0, 1.0, 1.0 ,-1.0, 1.0, -1.0 ,1.0, 1.0, -1.0 ,-1.0, -1.0, -1.0 ,1.0, -1.0, -1.0
	foreach hsp_normal:hsp_normal.cnt/=sqrt(3):loop//正規化

	dim face,24
	face   =0, 1, 3, 2 ,2, 3, 5, 4 ,4, 5, 7, 6 ,6, 7, 1, 0 ,1, 7, 5, 3 ,6, 0, 2, 4
	return

*ライト設定
	glEnable GL_LIGHTING
	glEnable GL_LIGHT0
	fdim light_pos,4
	light_pos=float(-5.01),float(3.01),float(4.0),float(0.0)
	return

*アンビエント等設定
	fdim ms_rubyambient,4:ms_rubyambient=  float(0.1),float(0.2),float(0.1),float(0.0)
	fdim ms_rubydiffuse,4:ms_rubydiffuse=  float(0.9),float(0.0),float(0.9),float(0.0)
	fdim ms_rubyspecular,4:ms_rubyspecular=float(1.0),float(1.0),float(0.2),float(0.0)
	fdim ms_shininess,1:ms_shininess=float(19.0)//スペキュラにはシャイネスの設定も必須
	glMaterialfv GL_FRONT_AND_BACK, GL_AMBIENT, varptr(ms_rubyambient)
	glMaterialfv GL_FRONT_AND_BACK, GL_DIFFUSE, varptr(ms_rubydiffuse)
	glMaterialfv GL_FRONT_AND_BACK, GL_SPECULAR, varptr(ms_rubyspecular):glMaterialfv GL_FRONT_AND_BACK, GL_SHININESS, varptr(ms_shininess)
	return

*VBO作成
	size_v=varsize(hsp_vertex)+varsize(hsp_normal)
	size_f=24*4//4はsizeof(int)
	HGLCreateBuffer GLmemid_v,CLmemid_v,size_v;VRAMにデータバッファ作成(VBO)
	HGLCreateBuffer GLmemid_f,CLmemid_f,size_f;VRAMにデータバッファ作成
	sdim dataa,size_v:memcpy dataa,hsp_vertex,varsize(hsp_vertex):memcpy dataa,hsp_normal,varsize(hsp_normal),varsize(hsp_vertex)
	HGLWriteBuffer GLmemid_v,dataa,size_v;hsp_vertex→GLmemid_v(VRAM)にデータ転送
	HGLWriteBuffer GLmemid_f,face ,size_f;face      →GLmemid_f(VRAM)にデータ転送
	sdim dataa,1
	return