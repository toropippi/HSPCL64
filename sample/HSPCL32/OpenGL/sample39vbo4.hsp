//「glDrawElements」応用編その１

#include "hspcl32.as"
	HCLini
	HGLSetView

	//立方体の頂点情報
	ddim hsp_vertex,24
	hsp_vertex =-1.0, -1.0, 1.0 ,1.0, -1.0, 1.0 ,-1.0, 1.0, 1.0 ,1.0, 1.0, 1.0 ,-1.0, 1.0, -1.0 ,1.0, 1.0, -1.0 ,-1.0, -1.0, -1.0 ,1.0, -1.0, -1.0

	//4つの頂点を1つの面とするので、面に対応する頂点を4つづつ登録,4*6
	dim face,24
	face   =0, 1, 3, 2 ,2, 3, 5, 4 ,4, 5, 7, 6 ,6, 7, 1, 0 ,1, 7, 5, 3 ,6, 0, 2, 4



	size_v=24*8//8はsizeof(double)
	size_f=24*4//4はsizeof(int)
	HGLCreateBuffer GLmemid_v,CLmemid_v,size_v;VRAMにデータバッファ作成(VBO)
	HGLCreateBuffer GLmemid_f,CLmemid_f,size_f;VRAMにデータバッファ作成
	HGLWriteBuffer GLmemid_v,hsp_vertex,size_v;hsp_vertex→GLmemid_v(VRAM)にデータ転送
	HGLWriteBuffer GLmemid_f,face      ,size_f;face      →GLmemid_f(VRAM)にデータ転送


//////こっから描画

    glClearColor 1.0, 1.0, 0.0, 1.0//背景色指定、ｗ成分は1.0


	repeat -1
		await 16
		glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
		glPushMatrix
		gluLookAt -4.0*sin(0.04*cnt),0.02*(mousex-320),0.02*(mousey-320),0.0,0.0,0.0,0.0,1.0,0.0

   		// 図形の描画
	    glColor3d 0.0,0.0,1.0;

		glEnableClientState GL_VERTEX_ARRAY//頂点データの配列を有効にする
		glBindBuffer GL_ARRAY_BUFFER,GLmemid_v//VBOをバインド
		glVertexPointer 3,GL_DOUBLE,0,0//頂点データの場所を指定する。今回はVBOを指定しているので0。中身はdouble型です。頂点情報は3つ(x,y,z)で一セットです

		glBindBuffer GL_ELEMENT_ARRAY_BUFFER,GLmemid_f//エレメントをバインド
		glDrawElements GL_QUADS, 24, GL_UNSIGNED_INT, 0//エレメントどおりの順番で描画
		glBindBuffer GL_ELEMENT_ARRAY_BUFFER,0//後片付け。エレメントをアンバインド

		glDisableClientState GL_VERTEX_ARRAY//後片付け。glEnableClientStateと対
		glBindBuffer GL_ARRAY_BUFFER,0//後片付け。バインド解除

		glPopMatrix
		glFinish
		SwapBuffers wglGetCurrentDC()
		getkey key,27:if key:HCLbye:end
	loop