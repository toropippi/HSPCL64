#include "HSPCL64.as"
	HCLinit

#define WX 128//変えるときはカーネルソースもかえること
#define WY 128//変えるときはカーネルソースもかえること
#define IM WX-1
#define JM WY-1
#define ijm WX*WY
#define ijm2 int(0.5*ijm)
#define ipn 4//変えるときはカーネルソースもかえること
#define konagire 4
#define taba 4
#define DT 0.5
#define DX 1.0
#define DY 1.0
#define にゅ〜 0.00001//粘性項
#define speeed 0.45

	rDT=1.0/DT
	arufa=にゅ〜*DT
	ar1fa=1.0/(1.0+4.0*arufa)

	screen 0,WX*ipn,WY*ipn
	mref iiii,66

	dim global_size,2
	dim local_size,2
	global_size=WX,WY
	local_size=128,1;１つのワークユニットに与える処理数、そのワークユニット内で共有メモリが使える

	prg=HCLCreateProgram("nabie.cl")
	krn00=HCLCreateKernel(prg,"newgrad")
	krn01=HCLCreateKernel(prg,"newgrad")
	krn02=HCLCreateKernel(prg,"newgrad")
	krn10=HCLCreateKernel(prg,"dcip0")
	krn11=HCLCreateKernel(prg,"dcip0")
	krn12=HCLCreateKernel(prg,"dcip0")
	krn50=HCLCreateKernel(prg,"nensei0")
	krn51=HCLCreateKernel(prg,"nensei1")
	krn20=HCLCreateKernel(prg,"pressure0")
	krn21=HCLCreateKernel(prg,"pressure1")
	krn22=HCLCreateKernel(prg,"div")
	//krn23=HCLCreateKernel(prg,"narasi")
	krn3=HCLCreateKernel(prg,"rhs")
	krn4=HCLCreateKernel(prg,"veloc")
	kout=HCLCreateKernel(prg,"out")
	kout0=HCLCreateKernel(prg,"out0")
	syokise=HCLCreateKernel(prg,"syokise")
	ryuusi=HCLCreateKernel(prg,"ryuusi")

	dim kkx,WX*WY
	repeat WX*WY:kkx.cnt=DoubleToFloat(0):loop

	YU=HCLCreateBufferFrom(kkx)
	YUN=HCLCreateBufferFrom(kkx)
	GXU=HCLCreateBufferFrom(kkx)
	GYU=HCLCreateBufferFrom(kkx)

	YV=HCLCreateBufferFrom(kkx)
	YVN=HCLCreateBufferFrom(kkx)
	GXV=HCLCreateBufferFrom(kkx)
	GYV=HCLCreateBufferFrom(kkx)	

	GXd0=HCLCreateBufferFrom(kkx)
	GYd0=HCLCreateBufferFrom(kkx)
	Yd0=HCLCreateBufferFrom(kkx)
	GXd1=HCLCreateBufferFrom(kkx)
	GYd1=HCLCreateBufferFrom(kkx)
	Yd1=HCLCreateBufferFrom(kkx)
	GXd2=HCLCreateBufferFrom(kkx)
	GYd2=HCLCreateBufferFrom(kkx)
	Yd2=HCLCreateBufferFrom(kkx)

	YP=HCLCreateBufferFrom(kkx)
	YPN=HCLCreateBufferFrom(kkx)
	GXP=HCLCreateBufferFrom(kkx)
	GYP=HCLCreateBufferFrom(kkx)

	YUT=HCLCreateBufferFrom(kkx)
	YVT=HCLCreateBufferFrom(kkx)
	YUV=HCLCreateBufferFrom(kkx)
	YVU=HCLCreateBufferFrom(kkx)
	DIV=HCLCreateBufferFrom(kkx)

	kabeP=HCLCreateBuffer(WX*WY):HCLWriteBuffer kabeP,kkx,WX*WY
	kabeX=HCLCreateBuffer(WX*WY):HCLWriteBuffer kabeX,kkx,WX*WY
	kabeY=HCLCreateBuffer(WX*WY):HCLWriteBuffer kabeY,kkx,WX*WY

	out=HCLCreateBuffer(3*WX*WY*ipn*ipn);画面
	RYS=HCLCreateBuffer(4*2*WX*WY*ipn*ipn)

	HCLSetKernel syokise,0,RYS
	HCLDoKrn1 syokise,WX*ipn*WY*ipn,local_size.0*local_size.1;

	dim kky,WX*WY

		repeat WY-1
		kkx(1+cnt*WX)=DoubleToFloat(speeed)
		loop
		repeat WY-1
		kkx(cnt*WX)=DoubleToFloat(speeed)
		loop

	HCLWriteBuffer YUN,kkx
	HCLWriteBuffer YVN,kky

	dim kbp,WX*WY/4
	dim kbx,WX*WY/4
	dim kby,WX*WY/4

	buffer 1:picload "kabep.png"
		repeat WX:a3=cnt:repeat WY
			pget a3,cnt:poke kbp,a3+cnt*WX,ginfo_r
		loop:loop

	buffer 1:picload "kabex.png"
		repeat WX:a3=cnt:repeat WY
			pget a3,cnt:poke kbx,a3+cnt*WX,ginfo_r
		loop:loop

	buffer 1:picload "kabey.png"
		repeat WX:a3=cnt:repeat WY
			pget a3,cnt:poke kby,a3+cnt*WX,ginfo_r
		loop:loop

	buffer 1:picload "kabew.png"
		repeat WX:a3=cnt:repeat WY
			pget a3,cnt
			if ginfo_r=0{
			poke kbp,a3+cnt*WX,0
			poke kbx,a3+cnt*WX,0
			poke kbx,(a3+1)\WX+cnt*WX,0
			poke kby,a3+cnt*WX,0
			poke kby,a3+((cnt+1)\WY)*WX,0
		}
		loop:loop

	HCLWriteBuffer kabeP,kbp,WX*WY
	HCLWriteBuffer kabeX,kbx,WX*WY
	HCLWriteBuffer kabeY,kby,WX*WY

	gsel 0


	dim kky,WX*WY
	dim kkx,WX*WY
	dim ryuusihspgawa,konagire*WY*ipn*2
		repeat konagire*WY*ipn
		w=cnt*2
		ryuusihspgawa.w=DoubleToFloat((1.940389/taba)*(cnt/(WY*ipn/taba)))
		w+
		ryuusihspgawa.w=DoubleToFloat((1.0*taba*cnt+0.5*taba+0.005)\(WY*ipn))
		loop
		
	gosub*syokisetei
	kirikaein=int(2.5/speeed)


////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;cip移流(壁のところでは参照はするが書き込みはしない)、	 f値とg(微分)値が同時に更新される
;本コピが完璧にあっている
;3次関数の部分では第4/5引数の速度はf3を参照、1から3引数はf3、g1を入力、係数もf3とg1から決定、f4、g2を出力
;差分式では、f3とg2を参照
;f4とg3を出力
;ここで一段落


;→外力	 f値のみ更新f0→f1
;→発散f1参照
;→圧力sor(壁のところでは参照はするが書き込みはしない)
;→圧力射影	 f値のみ更新f1→f2
;→cip微分値反映(ニューグレード、ソースでは圧力の更新しか反映されてないが、外力も含めないとダメ、さっきg値が更新された時のf値から今のf値までどのくらいずれたか)g0→g1、f0とf2参照
;→拡散、これはf値のみの更新でいい。f2→f3、f2参照
;→　　→　はじめへ
*keisan
	HCLCopyBuffer YU,YUN
	HCLCopyBuffer YV,YVN
	HCLCopyBuffer YP,YPN
	gosub*粘性
	if flm\8=0:gosub*外力
	gosub*pressure
	gosub*rhs
	gosub*newgrad
	gosub*veloc
	gosub*粒子
	if flm\kirikaein=(kirikaein-1):gosub*粒子復活
	if flm\8=0:gosub*表示
	gosub*dcip0
	if flm\8=0{
		getkey key,27:if key:end
		await 0
	}
	flm++
	flmps++
	goto*keisan

////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////メインルーチン////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*粘性
	HCLCopyBuffer GXd0,YUN
	HCLCopyBuffer GYd0,YVN
		repeat limit(10000.0*にゅ〜,0,(WX+WY)/2)
		HCLDoKernel krn50,2,global_size,local_size
		HCLDoKernel krn51,2,global_size,local_size
		loop
	return

*外力
	mkey=key1
	stick key1,256
	if key1&256{
		imaxx=mousex
		imayy=mousey
		if mkey=0:omxx=imaxx:omyy=imayy
		xzzzsa=omxx-imaxx
		yzzzsa=omyy-imayy
		if (xzzzsa!0)|(yzzzsa!0)|(1){
			HCLReadBuffer YUN,kkx,4*WX*WY
			HCLReadBuffer YVN,kky,4*WX*WY
				repeat 16
				wwwx=(imaxx/ipn+cnt\4)\WX
				wwwy=(imayy/ipn+cnt/4)\WY
				if peek(kbx,wwwx+wwwy*WX):kkx(wwwx+wwwy*WX)-=float(0.013*xzzzsa)
				if peek(kby,wwwx+wwwy*WX):kky(wwwx+wwwy*WX)-=float(0.013*yzzzsa)
				loop
			HCLWriteBuffer YUN,kkx,4*WX*WY
			HCLWriteBuffer YVN,kky,4*WX*WY

		}
		omxx=imaxx
		omyy=imayy
	}
	return

*pressure
	HCLDoKernel krn22,2,global_size,local_size;div計算

	HCLCopyBuffer YP,YPN
	//圧力計算はコストが高いのでとにかく最適化
		repeat WX
		HCLDoKrn1 krn20,ijm2,0
		HCLDoKrn1 krn21,ijm2,0//ローカルワークサイズはOpenCL実装に任せることに
		loop
	return

*rhs
	HCLDoKernel krn3,2,global_size,local_size
	return

*newgrad
	HCLDoKernel krn00,2,global_size,local_size
	HCLDoKernel krn01,2,global_size,local_size
	HCLDoKernel krn02,2,global_size,local_size
return

*veloc
	HCLCopyBuffer YU,YUN
	HCLCopyBuffer YV,YVN
	HCLDoKernel krn4,2,global_size,local_size

	HCLCopyBuffer GXd0,GXU
	HCLCopyBuffer GYd0,GYU
	HCLCopyBuffer Yd0,YUN

	HCLCopyBuffer GXd1,GXV
	HCLCopyBuffer GYd1,GYV
	HCLCopyBuffer Yd1,YVN

	HCLCopyBuffer GXd2,GXP
	HCLCopyBuffer GYd2,GYP
	HCLCopyBuffer Yd2,YPN
	return
*粒子
	HCLDoKrn1 ryuusi,WX*ipn*WY*ipn,local_size.0*local_size.1;
	return
*粒子復活
	HCLWriteBuffer RYS,ryuusihspgawa,konagire*WY*ipn*2*4,(konagire*WY*ipn*2*4*hktkais)\(WX*WY*ipn*ipn*4*2),0,1
	hktkais+
	return
*表示
	HCLDoKrn1 kout0,3*WX*WY*ipn*ipn/4,local_size.0*local_size.1;
	HCLDoKrn1 kout,WX*ipn*WY*ipn,local_size.0*local_size.1;
	HCLFinish
	HCLReadBuffer out,iiii,3*WX*WY*ipn*ipn
	pos 0,0:color 255,100,100
	redraw 1
	if mtim!gettime(6):mes "fps"+flmps:mflmps=flmps:flmps=0:else:mes "fps"+mflmps
	mtim=gettime(6)
	redraw 0
	return

*dcip0
	HCLDoKernel krn10,2,global_size,local_size
	HCLDoKernel krn11,2,global_size,local_size
	HCLDoKernel krn12,2,global_size,local_size
	return




*syokisetei
	HCLSetKernel krn50,0,YU
	HCLSetKernel krn50,1,YUN
	HCLSetKernel krn50,2,YV
	HCLSetKernel krn50,3,YVN
	HCLSetKernel krn50,4,GXd0
	HCLSetKernel krn50,5,GYd0
	HCLSetKernel krn50,6,DoubleToFloat(arufa)
	HCLSetKernel krn50,7,DoubleToFloat(ar1fa)
	HCLSetKernel krn50,8,kabeX
	HCLSetKernel krn50,9,kabeY

	HCLSetKernel krn51,0,YU
	HCLSetKernel krn51,1,YUN
	HCLSetKernel krn51,2,YV
	HCLSetKernel krn51,3,YVN
	HCLSetKernel krn51,4,GXd0
	HCLSetKernel krn51,5,GYd0
	HCLSetKernel krn51,6,DoubleToFloat(arufa)
	HCLSetKernel krn51,7,DoubleToFloat(ar1fa)
	HCLSetKernel krn51,8,kabeX
	HCLSetKernel krn51,9,kabeY

	HCLSetKernel krn22,1,YUN
	HCLSetKernel krn22,2,YVN
	HCLSetKernel krn22,0,DIV

	HCLSetKernel krn20,0,DIV
	HCLSetKernel krn20,1,YPN
	HCLSetKernel krn20,2,kabeP
	HCLSetKernel krn21,0,DIV
	HCLSetKernel krn21,1,YPN
	HCLSetKernel krn21,2,kabeP

	//HCLSetKernel krn23,0,YPN
	//HCLSetKernel krn23,1,yp00

	HCLSetKernel krn3,0,YUN
	HCLSetKernel krn3,1,YVN
	HCLSetKernel krn3,2,YPN
	HCLSetKernel krn3,3,kabeX
	HCLSetKernel krn3,4,kabeY

	HCLSetKernel krn02,0,YUN
	HCLSetKernel krn02,1,YU
	HCLSetKernel krn02,2,GXU
	HCLSetKernel krn02,3,GYU
	HCLSetKernel krn02,4,kabeX

	HCLSetKernel krn00,0,YVN
	HCLSetKernel krn00,1,YV
	HCLSetKernel krn00,2,GXV
	HCLSetKernel krn00,3,GYV
	HCLSetKernel krn00,4,kabeY

	HCLSetKernel krn01,0,YPN
	HCLSetKernel krn01,1,YP
	HCLSetKernel krn01,2,GXP
	HCLSetKernel krn01,3,GYP
	HCLSetKernel krn01,4,kabeP

	HCLSetKernel krn4,0,YU
	HCLSetKernel krn4,1,YV
	HCLSetKernel krn4,2,YVU
	HCLSetKernel krn4,3,YUV
	HCLSetKernel krn4,4,YVT
	HCLSetKernel krn4,5,YUT

	HCLSetKernel krn10,0,YUN
	HCLSetKernel krn10,1,GXU
	HCLSetKernel krn10,2,GYU
	HCLSetKernel krn10,3,YU
	HCLSetKernel krn10,4,YVU
	HCLSetKernel krn10,5,GXd0
	HCLSetKernel krn10,6,GYd0
	HCLSetKernel krn10,7,Yd0
	HCLSetKernel krn10,8,DoubleToFloat(DT)
	HCLSetKernel krn10,9,kabeX

	HCLSetKernel krn11,0,YVN
	HCLSetKernel krn11,1,GXV
	HCLSetKernel krn11,2,GYV
	HCLSetKernel krn11,3,YUV
	HCLSetKernel krn11,4,YV
	HCLSetKernel krn11,5,GXd1
	HCLSetKernel krn11,6,GYd1
	HCLSetKernel krn11,7,Yd1
	HCLSetKernel krn11,8,DoubleToFloat(DT)
	HCLSetKernel krn11,9,kabeY

	HCLSetKernel krn12,0,YPN
	HCLSetKernel krn12,1,GXP
	HCLSetKernel krn12,2,GYP
	HCLSetKernel krn12,3,YUT
	HCLSetKernel krn12,4,YVT
	HCLSetKernel krn12,5,GXd2
	HCLSetKernel krn12,6,GYd2
	HCLSetKernel krn12,7,Yd2
	HCLSetKernel krn12,8,DoubleToFloat(DT)
	HCLSetKernel krn12,9,kabeP
	
	HCLSetKernel kout,0,out
	HCLSetKernel kout,1,RYS
	HCLSetKernel kout,2,YU
	HCLSetKernel kout,3,YV

	HCLSetKernel ryuusi,0,RYS
	HCLSetKernel ryuusi,1,YUN
	HCLSetKernel ryuusi,2,YVN
	HCLSetKernel ryuusi,3,DoubleToFloat(DT)
	HCLSetKernel ryuusi,4,GXU
	HCLSetKernel ryuusi,5,GYU
	HCLSetKernel ryuusi,6,GXV
	HCLSetKernel ryuusi,7,GYV

	HCLSetKernel kout0,0,out
	return
	