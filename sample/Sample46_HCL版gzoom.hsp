//HSPのgzoom命令に相当することOpenCLで実行します。
//これをさらに改造すればgmode 4的な透明処理とかも実現できます。
//注意としてはmref命令で画面情報を取得するため、画面横幅が4の倍数でないといけないです。
#include "HSPCL64.as"
	HCLinit

	screen 0,320,240
		repeat 123
		pos rnd(320),rnd(240)
		mes rnd(32766)
		loop
	screen 1,424,344
	
	HCLgzoom 0,1//0→1に拡大縮小
	gsel 1
	redraw 1
	stop



#module

#deffunc HCLgzoom int gselid0, int gselid1
	gsel gselid0
	wx0=ginfo(12)
	wy0=ginfo(13)
	if wx0\4!=0:dialog "画面の横幅が4の倍数でないと予期しない動作が起こります。",1
	mref host_g0,66//これを拡大縮小コピーしたい。アンチエイジング付きで
	
	gsel gselid1
	wx1=ginfo(12)
	wy1=ginfo(13)
	if wx1\4!=0:dialog "画面の横幅が4の倍数でないと予期しない動作が起こります。",1
	mref host_g1,66
	
	HCLCall {"__kernel void gzoom(__global unsigned char* g0,__global unsigned char* g1
	,int wx0,int wy0,int wx1,int wy1)
	{
		int gid=get_global_id(0);
		int x=gid%wx1;
		int y=gid/wx1;
		
		int srclx=x*wx0;
		int srcrx=(x+1)*wx0;
		int srcly=y*wy0;
		int srcry=(y+1)*wy0;

		ulong r_sm=0;
		ulong g_sm=0;
		ulong b_sm=0;

		int read_x=(srclx/wx1+1)*wx1;
		int read_y=(srcly/wy1+1)*wy1;
		int l=srclx;
		int u=srcly;

		for(int d=read_y;;)
		{
			if (d>=srcry)d=srcry;
			int ysz=d-u;
			for(int r=read_x,l=srclx;;)
			{
				if (r>=srcrx)r=srcrx;
				int xsz=r-l;
				b_sm+=ysz*xsz*(int)g0[(l/wx1+(u/wy1)*wx0)*3+0];
				g_sm+=ysz*xsz*(int)g0[(l/wx1+(u/wy1)*wx0)*3+1];
				r_sm+=ysz*xsz*(int)g0[(l/wx1+(u/wy1)*wx0)*3+2];
				l=r;
				if (l>=srcrx)break;
				r+=wx1;
			}
			u=d;
			if (u>=srcry)break;
			d+=wy1;
		}

		ulong rev=wx0*wy0;
		g1[(x+y*wx1)*3+0] = (unsigned char)(b_sm/rev);
		g1[(x+y*wx1)*3+1] = (unsigned char)(g_sm/rev);
		g1[(x+y*wx1)*3+2] = (unsigned char)(r_sm/rev);
	}
"},wx1*wy1,0,host_g0,host_g1,wx0,wy0,wx1,wy1
	return
#global