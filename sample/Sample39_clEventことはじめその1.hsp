//これ以降、event関連のサンプルが多いです。
//eventはHCLReadBuffer,HCLWriteBufferやHCLDoKrn1などに関連付けられ、それぞれ実行時間や実行状況の取得、実行条件の指定をできるのでとても便利です。

//HCLGetEventLogsでeventの実行時間などを取得できます。
//HCLGetEventStatusでeventが実行終了しているかどうかの判定ができます。
//HCLSetWaitEvent、HCLSetWaitEventsで任意のコマンドに任意のeventの終了待ちができます。
//HCLWaitForEvent、HCLWaitForEventsでCPUがeventの終了待ちを行います。
//HCLCreateUserEvent、HCLSetUserEventStatusでUser_eventを作成したり状態をsetすることができます。
//_ExHCLSetEventMaxをHCLInitの前に実行することで、eventの上限を増やすことができます。デフォルトではevent id 0〜65535まで使えます

//まずはHCLGetEventLogsで、手動でプロファイリングのコードを作ってみたというサンプルです。
#include "HSPCL64.as"
	randomize
	HCLinit
	prg=HCLCreateProgram("VecAdd.cl")
	krn=HCLCreateKernel(prg,"vecAdd")
	
	n=65536
	clmem_A=HCLCreateBuffer(n*4)
	clmem_B=HCLCreateBuffer(n*4)
	clmem_C=HCLCreateBuffer(n*4)
	
	dim host_A,n
	dim host_B,n
	dim host_C,n
		repeat n
		host_A.cnt=cnt
		host_B.cnt=cnt
		loop
	
	HCLWriteBuffer clmem_A,host_A,n*4,,,,0//event_id 0
	HCLWriteBuffer clmem_B,host_B,n*4,,,,1//event_id 1
	
	HCLSetKrns krn,clmem_A,clmem_B,clmem_C
	
	HCLDoKrn1 krn,n,64,2//event_id 2
	//HCLFinish//このHCLFinishは本来いらないけどいれたらAMD GPUのgfx902でもkrnの正しいtimeスタンプ取得できた
	HCLReadBuffer clmem_C,host_C,n*4,,,,3//event_id 3
	
	//eventから時間情報を取得。返り値は64bit int
	event_num=4
	gosub*view1
	gosub*view2
	stop
	

*view1
	//まずはすべての計算時間を取得
	dim_i64 kinfo,event_num
	sdim kinfos,128,event_num
	dim_i64 start_time,event_num
	dim_i64 end_time,event_num
		repeat event_num
		start_time.cnt=HCLGetEventLogs(cnt,6)//6はCL_PROFILING_COMMAND_STARTのtime
		end_time.cnt=HCLGetEventLogs(cnt,7)//7はCL_PROFILING_COMMAND_ENDのtime
		
		kinfo.cnt=HCLGetEventLogs(cnt,0)//0はeventがなんのコマンドだったか取得
		if kinfo.cnt==CL_COMMAND_WRITE_BUFFER  :kinfos.cnt="WRITE_BUFFER"
		if kinfo.cnt==CL_COMMAND_READ_BUFFER   :kinfos.cnt="READ_BUFFER"
		if kinfo.cnt==CL_COMMAND_NDRANGE_KERNEL:kinfos.cnt="KERNEL"
		loop
		
	offset=start_time.0
	
		repeat event_num
		start_time.cnt-=offset
		end_time.cnt-=offset
		loop

	scalex=end_time.(event_num-1)
	

	//計算時間をグラフで表示
	//軸
	line 30,30,30,450
	pos 3,240

	line 30,450,620,450
	line 620,450,615,447
	line 620,450,615,453
	pos 270,460
	font msgothic,12
	mes "時間(μs)"
		repeat 9
		line 30+cnt*580/8,450,30+cnt*580/8,445
		pos 30+cnt*580/8,450
		mes scalex*cnt/8000
		loop
		
	return


*view2
	//実行単位で表示していく
		repeat event_num
			hsvcolor rnd(192),200,200
			lx=start_time.cnt*580/scalex+30
			rx=end_time.cnt*580/scalex+30
			boxf int(lx),200,int(rx),240
			pos int(lx),190-(cnt==2)*10
			color 0,0,0
			mes kinfos.cnt
		loop
	return




//一部のAMD GPU(例えばgfx902)だとkernel実行開始終了時間と、データ転送開始終了時間でズレが生じて、それぞれバラバラの時間が取得されるというバグ？不具合？仕様？があります。
//これだからOpenCL・・いやなんでも
//と思っていたらHCLDoKrn1のあとHCLFinishをいれることで正しいtimeが取得できた。でもいちいちカーネル実行終了待ちしてはパフォーマンス出せないし結局使えないんじゃ・・・いやなんでも