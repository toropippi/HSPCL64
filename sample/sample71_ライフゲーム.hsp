//GPUに確保したメモリの中で最大値、最小値を求めたいや、合計値を求めたい
//というときに全部の配列を参照する必要があり、このような操作をリダクションといいます。
#include "HSPCL64.as"
	HCLinit
#const WX 512
#const WY 512

	source={"
__kernel void GameMain(__global int* A,__global int* B)
{
	int gid = get_global_id(0);
	int x=gid%WX;
	int y=gid/WX;
	int idx=x+y*WX;

	int mycell=A[idx];
	
	int cell0=A[(x-1+WX)%WX+(y+WY-1)%WY*WX];
	int cell1=A[x          +(y+WY-1)%WY*WX];
	int cell2=A[(x+1)%WX   +(y+WY-1)%WY*WX];

	int cell3=A[(x-1+WX)%WX+y*WX];
	int cell4=A[(x+1)%WX   +y*WX];
	
	int cell5=A[(x-1+WX)%WX+(y+1)%WY*WX];
	int cell6=A[x          +(y+1)%WY*WX];
	int cell7=A[(x+1)%WX   +(y+1)%WY*WX];

	int sm=cell0+cell1+cell2+cell3+cell4+cell5+cell6+cell7;

	if (mycell==0)
	{
		if (sm==3) mycell=1;
	}
	else
	{
		if ((sm<=1)|(sm>=4)) mycell=0;
	}

	B[idx]=mycell;
}

__kernel void CellView(__global int* A,__global uchar* vrm)
{
	int gid = get_global_id(0);
	int x=gid%WX;
	int y=gid/WX;
	int idx=x+y*WX;

	int mycell=A[idx];

	idx=((WY-1-y)*WX+x)*3;
	vrm[idx+0]=0;//b
	vrm[idx+1]=(uchar)mycell*190;//g
	vrm[idx+2]=0;//r
}
"}

	prg=HCLCreateProgramWithSource(source,"-D WX="+WX+" -D WY="+WY+"")
	krnGameMain=HCLCreateKernel(prg,"GameMain")
	krnCellView=HCLCreateKernel(prg,"CellView")

	//メモリ初期化、カーネル設定
	memA=HCLCreateBuffer(WX*WY*4)
	memB=HCLCreateBuffer(WX*WY*4)
	memvrm=HCLCreateBuffer(WX*WY*3)
	HCLFillBuffer_i32 memA,0
	HCLFillBuffer_i32 memB,0

	gosub*重量級宇宙船
	gosub*ダイハード
	gosub*どんぐり
	
	screen 0,WX,WY
	mref vrm,66

*main
	HCLSetKrns krnGameMain,memA,memB
	HCLDokrn1 krnGameMain,WX*WY,64
	HCLSetKrns krnCellView,memB,memvrm
	HCLDokrn1 krnCellView,WX*WY,64
	
	HCLReadBuffer memvrm,vrm
	redraw 1
	await 16
	
	tmp=memA//swap3行
	memA=memB//swap3行
	memB=tmp//swap3行
	goto*main


*重量級宇宙船
	//重量級宇宙船をセット
	idx=WX/2*WY+WX/2
	HCLWriteIndex_i32 memA,idx+3,1
	HCLWriteIndex_i32 memA,idx+4,1
	HCLWriteIndex_i32 memA,idx+WX+1,1
	HCLWriteIndex_i32 memA,idx+WX+6,1
	HCLWriteIndex_i32 memA,idx+WX*2,1
	HCLWriteIndex_i32 memA,idx+WX*3,1
	HCLWriteIndex_i32 memA,idx+WX*3+6,1
	HCLWriteIndex_i32 memA,idx+WX*4+0,1
	HCLWriteIndex_i32 memA,idx+WX*4+1,1
	HCLWriteIndex_i32 memA,idx+WX*4+2,1
	HCLWriteIndex_i32 memA,idx+WX*4+3,1
	HCLWriteIndex_i32 memA,idx+WX*4+4,1
	HCLWriteIndex_i32 memA,idx+WX*4+5,1
	return
	
*どんぐり
	//どんぐりをセット
	idx=WX/7*WY+WX*2/3
	HCLWriteIndex_i32 memA,idx+1,1
	HCLWriteIndex_i32 memA,idx+WX+3,1
	HCLWriteIndex_i32 memA,idx+WX*2,1
	HCLWriteIndex_i32 memA,idx+WX*2+1,1
	HCLWriteIndex_i32 memA,idx+WX*2+4,1
	HCLWriteIndex_i32 memA,idx+WX*2+5,1
	HCLWriteIndex_i32 memA,idx+WX*2+6,1
	return

*ダイハード
	idx=WX/2*WY+WX+WX/2-30
	HCLWriteIndex_i32 memA,idx+6,1
	HCLWriteIndex_i32 memA,idx+WX,1
	HCLWriteIndex_i32 memA,idx+WX+1,1
	HCLWriteIndex_i32 memA,idx+WX*2+1,1
	HCLWriteIndex_i32 memA,idx+WX*2+5,1
	HCLWriteIndex_i32 memA,idx+WX*2+6,1
	HCLWriteIndex_i32 memA,idx+WX*2+7,1
	return