//こちらはinoviaさんの作成したHSPint64のサンプルそのままです。
//最新版はこちらをhttps://github.com/inovia/HSPInt64
//HSPCL64を作るためにint64の機能がどうしても必要であり、下記命令を拝借させて頂いております。

#include "HSPCL64.as"
#define MB_ICONINFORMATION $40
#define MB_OK 0
#uselib "user32.dll"
#func MessageBox "MessageBoxA" int,int,int,int

	INT64_ZERO = int64(0)
	INT64_ONE = int64(1)

	a = "こんにちは"
	b = "てすと"

	// ウィンドウハンドルは64bitアプリでも32bit分しか使っていない
	// https://msdn.microsoft.com/en-us/library/aa384203(VS.85).aspx
	// int64(hwnd) でOK!
	
	dimtype prmData, vartype("int64"), 4
	prmData = int64(hwnd), varptr64(a), varptr64(b), int64(MB_OK | MB_ICONINFORMATION)
	
	dimtype prmInfo, vartype("int64"), 4
	prmInfo = INT64_ZERO, INT64_ZERO, INT64_ZERO, INT64_ZERO
	
	// 
	// callfunc64i()
	// 外部関数を実行します
	// 戻り値: int64
	// 
	// 第1引数: 実行先関数の引数データ（配列）
	// 第2引数: 実行先関数の引数の型情報（配列）
	//          引数が int/int64の場合は、INT64_ZERO
	//          引数が flaot/doubleの場合は、INT64_ONE
	//          を指定します。
	// 第3引数: 関数のアドレス
	// 第4引数: 実行先関数の引数の数 (= 配列の要素数)
	// 
	// ※ 戻り値がdouble版は「callfunc64d」関数
	//            float版は「callfunc64f」関数
	// 
	mes "MessageBox()の戻り値: " + callfunc64i(prmData, prmInfo, varptr64(MessageBox), 4)

	// 
	// int64()
	// int64型の変数に変換します
	// 戻り値: int64
	//
	// 第1引数: 変換元値または変数(文字列,数値,実数)
	// 
	mes "int64最大値: " + int64("9223372036854775807")
	
	// 
	// qpoke
	// バッファに8byte書き込み
	// 
	// ※ poke系命令の8byte版です。
	//    使い方は同じです。
	// 

	sdim buf, 64
	qpoke buf, 0, int64("9223372036854775807")
	
	// 
	// qpeek()
	// バッファから8byte読み出し
	// 戻り値: int64
	// 
	// ※ peek系関数の8byte版です。
	//    使い方は同じです。
	// 
	mes "bufの先頭から8バイト読み込む: " + qpeek(buf, 0)
	
	//
	// varptr64()
	// 変数/命令/関数のポインタを返す
	// 戻り値: int64
	// 
	// ※ varptr関数の64bit版です。
	//    使い方は同じです。
	// 
	ptr = varptr64(MessageBox)
	mes "MessageBox()のポインタ: " + ptr
	
	a = "あいうえお"
	mes "a: " + a
	aPtr = varptr64(a)
	
	//
	// dupptr64
	// ポインタからクローン変数を作成
	// 
	// ※ dupptr命令の64bit版です。
	//    使い方は同じです。
	// 
	
	dupptr64 b, aPtr, 64, vartype("str")
	mes "b: " + b