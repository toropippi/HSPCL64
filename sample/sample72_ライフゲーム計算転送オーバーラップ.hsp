//GPUの計算はライフゲームの計算とmemvrmの計算
//GPU→CPUでmemvrmから読み込むため、ライフゲームの計算とGPU(memvrm)→CPUがオーバーラップできるはずである
#include "HSPCL64.as"
#include "ViewTimeStamp_module.as"
	HCLinit
#const WX 512
#const WY 512

	HCLSetDevice 0
	prg=HCLCreateProgram("LifeGame.cl","-D WX="+WX+" -D WY="+WY+"")
	krnGameMain=HCLCreateKernel(prg,"GameMain")
	krnCellView=HCLCreateKernel(prg,"CellView")

	//メモリ初期化、カーネル設定
	memA=HCLCreateBuffer(WX*WY*4)
	memB=HCLCreateBuffer(WX*WY*4)
	memvrm=HCLCreateBuffer(WX*WY*3)
	HCLFillBuffer_i32 memA,0
	HCLFillBuffer_i32 memB,0

	gosub*重量級宇宙船
	gosub*ダイハード
	gosub*どんぐり

	screen 1,640,480
	screen 0,WX,WY
	mref vrm,66


	HCLSetCommandQueue 0
	//ライフゲーム計算
	HCLSetKrns krnGameMain,memA,memB
	HCLDokrn1 krnGameMain,WX*WY,64

	event_id=0
*main
	//画像変換計算
	HCLSetKrns krnCellView,memB,memvrm
	HCLDokrn1 krnCellView,WX*WY,64,event_id
	event_id++

	//GPU→CPU
	HCLSetCommandQueue 1
	HCLSetWaitEvent event_id-1//さっきのmemB→memvrmが終わらないと読み込んでほしくない
	HCLReadBuffer memvrm,vrm,,,,0,event_id
	lastReadBufferEventid=event_id
	event_id++

	HCLSetCommandQueue 0
	//ライフゲーム計算、これをGPU→CPUの転送中に行いたい
	tmp=memA//swap3行
	memA=memB//swap3行
	memB=tmp//swap3行
	HCLSetKrns krnGameMain,memB,memA
	HCLDokrn1 krnGameMain,WX*WY,64,event_id
	event_id++

	repeat -1//転送が終了したらループを抜ける
		await 0
		if HCLGetEventStatus(lastReadBufferEventid)==0:break
	loop
	redraw 1//描画
	
	if ((count\1024>1020)&(event_id>6)){
		count=0
		gsel 1
		color 255,255,255:boxf:color 0,0,0
		ViewEvents3 event_id-1
		gsel 0
	}
	
	gosub*fpsview
	count++
	
	if event_id>=8:event_id=0
	goto*main

*fpsview
	flm++
	if ms!gettime(6):ms=gettime(6):fps=flm:flm=0
	pos 0,0:color 255,55,55:mes "fps="+fps+""
	return

*重量級宇宙船
	//重量級宇宙船をセット
	idx=WX/2*WY+WX/2
	HCLWriteIndex_i32 memA,idx+3,1
	HCLWriteIndex_i32 memA,idx+4,1
	HCLWriteIndex_i32 memA,idx+WX+1,1
	HCLWriteIndex_i32 memA,idx+WX+6,1
	HCLWriteIndex_i32 memA,idx+WX*2,1
	HCLWriteIndex_i32 memA,idx+WX*3,1
	HCLWriteIndex_i32 memA,idx+WX*3+6,1
	HCLWriteIndex_i32 memA,idx+WX*4+0,1
	HCLWriteIndex_i32 memA,idx+WX*4+1,1
	HCLWriteIndex_i32 memA,idx+WX*4+2,1
	HCLWriteIndex_i32 memA,idx+WX*4+3,1
	HCLWriteIndex_i32 memA,idx+WX*4+4,1
	HCLWriteIndex_i32 memA,idx+WX*4+5,1
	return
	
*どんぐり
	//どんぐりをセット
	idx=WX/7*WY+WX*2/3
	HCLWriteIndex_i32 memA,idx+1,1
	HCLWriteIndex_i32 memA,idx+WX+3,1
	HCLWriteIndex_i32 memA,idx+WX*2,1
	HCLWriteIndex_i32 memA,idx+WX*2+1,1
	HCLWriteIndex_i32 memA,idx+WX*2+4,1
	HCLWriteIndex_i32 memA,idx+WX*2+5,1
	HCLWriteIndex_i32 memA,idx+WX*2+6,1
	return

*ダイハード
	idx=WX/2*WY+WX+WX/2-30
	HCLWriteIndex_i32 memA,idx+6,1
	HCLWriteIndex_i32 memA,idx+WX,1
	HCLWriteIndex_i32 memA,idx+WX+1,1
	HCLWriteIndex_i32 memA,idx+WX*2+1,1
	HCLWriteIndex_i32 memA,idx+WX*2+5,1
	HCLWriteIndex_i32 memA,idx+WX*2+6,1
	HCLWriteIndex_i32 memA,idx+WX*2+7,1
	return